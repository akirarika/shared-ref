(function(n,u){typeof exports=="object"&&typeof module<"u"?u(exports,require("vue")):typeof define=="function"&&define.amd?define(["exports","vue"],u):(n=typeof globalThis<"u"?globalThis:n||self,u(n.SharedRef={},n.Vue))})(this,function(n,u){"use strict";var T=Object.defineProperty;var L=(n,u,i)=>u in n?T(n,u,{enumerable:!0,configurable:!0,writable:!0,value:i}):n[u]=i;var W=(n,u,i)=>L(n,typeof u!="symbol"?u+"":u,i);var i="SharedWorker"in globalThis,w=class{constructor(e,r){W(this,"ActualWorker");i?this.ActualWorker=new SharedWorker(e,r):this.ActualWorker=new Worker(e,r)}get onmessage(){var e;return i?(e=this.ActualWorker)==null?void 0:e.port.onmessage:this.ActualWorker.onmessage}set onmessage(e){i?this.ActualWorker.port.onmessage=e:this.ActualWorker.onmessage=e}get onmessageerror(){var e;return i?(e=this.ActualWorker)==null?void 0:e.port.onmessageerror:this.ActualWorker.onmessageerror}set onmessageerror(e){i?this.ActualWorker.port.onmessageerror=e:this.ActualWorker.onmessageerror=e}start(){var e;if(i)return(e=this.ActualWorker)==null?void 0:e.port.start()}postMessage(e,r){var t;return i?(t=this.ActualWorker)==null?void 0:t.port.postMessage(e,r):this.ActualWorker.postMessage(e,r)}terminate(){var e;return i?(e=this.ActualWorker)==null?void 0:e.port.close():this.ActualWorker.terminate()}close(){return this.terminate()}get port(){return i?this.ActualWorker.port:this.ActualWorker}get onerror(){return this.ActualWorker.onerror}set onerror(e){this.ActualWorker.onerror=e}addEventListener(e,r,t){var a;return i&&e!=="error"?(a=this.ActualWorker)==null?void 0:a.port.addEventListener(e,r,t):this.ActualWorker.addEventListener(e,r,t)}removeEventListener(e,r,t){var a;return i&&e!=="error"?(a=this.ActualWorker)==null?void 0:a.port.removeEventListener(e,r,t):this.ActualWorker.removeEventListener(e,r,t)}dispatchEvent(e){return this.ActualWorker.dispatchEvent(e)}};function g(){let e,r;return{promise:new Promise((a,c)=>{e=a,r=c}),resolve:e,reject:r}}const p="useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";let A=(e=21)=>{let r="",t=crypto.getRandomValues(new Uint8Array(e));for(;e--;)r+=p[t[e]&63];return r},y;const m=g(),v=new Map,h=new Map,R=e=>{y=new w(e.url,{type:"module"}),y.port.start(),y.addEventListener("message",r=>{e!=null&&e.debug&&console.log("[SharedRef] onmessage",r);const t=r.data;if(t.type==="PONG")m.resolve(void 0);else if(t.type==="RESULT"){const a=v.get(t.id);a==null||a.resolve(t)}else if(t.type==="SYNC"){const a=h.get(t.key);a&&(a.value=t.value,a.trigger())}}),y.postMessage({type:"PING"}),typeof window>"u"&&(window.sharedRef=S)},S=async e=>{if(!y)throw new Error("[SharedRef] Shared worker not initialized, call initSharedRef(...) first.");await m.promise;const r=g(),t=`${e.key}_${A()}`;v.set(t,r),y.postMessage({type:"GET",key:e.key,meta:e.meta??{},id:t});let a;const c=await r.promise;c.empty===!1?a=c.value:a=e.value;const o={};if(o.ref=u.customRef((f,l)=>(o.track=f,o.trigger=l,o.value=a,{get(){return o.track(),o.value},set(d){o.value=d,o.trigger(),y.postMessage({type:"SET",key:e.key,meta:e.meta??{},value:d})}})),h.has(e.key))throw new Error(`[SharedRef] Multiple sharedRefs are using the same key: '${e.key}'.`);return h.set(e.key,o),o.ref},E=e=>{var f;const r=new Set,t=new Map,a=(f=e==null?void 0:e.bootstrap)==null?void 0:f.call(e),c=async(l,d)=>{e!=null&&e.debug&&console.log("[SharedRefWorker] onmessage",d);const s=d.data;if(s.type==="PING")await a,l.postMessage({type:"PONG"});else if(s.type==="GET")if("getHandler"in e)try{const{empty:k,value:M}=await e.getHandler({key:s.key,meta:s.meta});k?l.postMessage({type:"RESULT",key:s.key,id:s.id,value:void 0,empty:!0}):l.postMessage({type:"RESULT",key:s.key,id:s.id,value:M,empty:!1})}catch(k){console.error(k)}else t.has(s.key)?l.postMessage({type:"RESULT",key:s.key,id:s.id,value:t.get(s.key),empty:!1}):l.postMessage({type:"RESULT",key:s.key,id:s.id,value:void 0,empty:!0});else if(s.type==="SET"){if("getHandler"in e)try{e.waiting?await e.setHandler({key:s.key,value:s.value,meta:s.meta}):e.setHandler({key:s.key,value:s.value,meta:s.meta})}catch(k){console.error(k)}else t.set(s.key,s.value);for(const k of r)k!==l&&k.postMessage({type:"SYNC",key:s.key,value:s.value})}},o=l=>{r.add(l),l.onmessage=d=>c(l,d)};return self.onconnect=l=>{e!=null&&e.debug&&console.log("[SharedRefWorker] onconnect",l);const[d]=l.ports;o(d)},"SharedWorkerGlobalScope"in self||o(self),{broadcast(l,d){for(const s of r)s.postMessage({type:"SYNC",key:l,value:d})}}},b=()=>{let e;return{async bootstrap(){const r=indexedDB.open("shared_ref_database",1),{promise:t,resolve:a,reject:c}=g();r.onupgradeneeded=o=>{const f=o.target.result;f.objectStoreNames.contains("data")||f.createObjectStore("data",{keyPath:"key"})},r.onsuccess=o=>{e=o.target.result,a(e)},r.onerror=c,await t},async getHandler(r){const{promise:t,resolve:a,reject:c}=g(),o=e.transaction(["data"],"readonly").objectStore("data").get(r.key);o.onsuccess=a,o.onerror=c;const f=(await t).target.result;return f?{empty:!1,value:f.value}:{empty:!0,value:void 0}},async setHandler(r){const{promise:t,resolve:a,reject:c}=g(),o=e.transaction(["data"],"readwrite").objectStore("data").put({key:r.key,value:r.value});o.onsuccess=a,o.onerror=c,await t}}};n.IndexedDBHandler=b,n.defineSharedRefWorker=E,n.initSharedRef=R,n.sharedRef=S,n.withResolvers=g,Object.defineProperty(n,Symbol.toStringTag,{value:"Module"})});
